use [AdventureWorks2012]

--
SELECT * FROM [HumanResources].[Department]

-- SHOW ME ALL THE DEPARTMENT NAMES
SELECT NAME FROM 

-- SHOW ME ALL THE GROUPS
SELECT GROUPNAME FROM [HumanResources].[Department]

--SHOW ME ALL THE DISTINCT (unique) GROUP NAMES
SELECT DISTINCT GROUPNAME FROM [HumanResources].[Department]

-- SHOW ME ALL THE DEPARTMENT NAMES THAT ARE PART OF MANUFACTURING
SELECT NAME, GROUPNAME FROM [HumanResources].[Department]
WHERE GROUPNAME LIKE 'MANUFACTURING'

-- SHOW ME ALL EMPLOYEES FROM THE EMPLOYEE TABLE
SELECT * FROM [HumanResources].[Employee]

-- SHOW ME A LIST OF ALL EMPLOYEES WHO HAVE AN ORGANISATION LEVEL OF 2
SELECT * FROM [HumanResources].[Employee]
WHERE OrganizationLevel = 2

-- SHOW ME A LIST OF ALL EMPLOYEES WHO HAVE AN ORGANISATION LEVEL OF 2 OR 3
SELECT * FROM [HumanResources].[Employee]
WHERE OrganizationLevel IN (2,3)

-- SHOW ME ALL EMPLOYEES WHO HAVE A TITLE OF FACILITIES MANAGER
SELECT * FROM [HumanResources].[Employee]
WHERE JOBTITLE LIKE 'Facilities Manager'

-- SHOW ME ALL EMPLOYEES WHO HAVE MANAGER AT THE END OF THEIR TITLE
SELECT * FROM [HumanResources].[Employee]
WHERE JOBTITLE LIKE '%Manager'

-- SHOW ME ALL EMPLOYEES WHO HAVE CONTROL IN THEIR TITLE
SELECT * FROM [HumanResources].[Employee]
WHERE JOBTITLE LIKE '%Control%'

--SHOW ME ALL EMPLOYEES BORN AFTER JAN 1 1980
SELECT * FROM [HumanResources].[Employee]
WHERE BIRTHDATE > '1/1/1980'

--SHOW ME ALL EMPLOYEES BORN BETWEEN JAN 1 1970 AND JAN 1 1980
SELECT * FROM [HumanResources].[Employee]
WHERE BIRTHDATE BETWEEN '1/1/1970' AND '1/1/1980'


--CALCULATED COLUMNS - Create a temporary column
SELECT NAME, LISTPRICE, LISTPRICE + 10 AS ADJUSTED_LIST_PRICE FROM [Production].[Product]

--INTO CLAUSE - CREATING A NEW COLUMN FOR A NEW TABLE
SELECT NAME, LISTPRICE, LISTPRICE + 10 AS ADJUSTED_LIST_PRICE INTO [Production].[Product_2] FROM [Production].[Product]

SELECT * FROM [Production].[Product_2]

-- DELETE DATA FROM TABLE
DELETE FROM [Production].[Product_2]
WHERE NAME LIKE 'Bearing Ball'

SELECT * FROM [Production].[Product_2]

-- UPDATE
UPDATE [Production].[Product_2]
SET NAME = 'BLADE_NEW'
WHERE NAME LIKE 'BLADE'

SELECT * FROM [Production].[Product_2]

-------JOINS---------

--CREATING EXAMPLE TABLES
CREATE TABLE MYEMPLOYEE (EMPLOYEEID INT, FIRSTNAME VARCHAR(20), LASTNAME VARCHAR(20))

INSERT INTO MYEMPLOYEE VALUES (1, 'Michael', 'Scott')
INSERT INTO MYEMPLOYEE VALUES (2, 'Pam', 'Beesly')
INSERT INTO MYEMPLOYEE VALUES (3, 'MDwight', 'Schrute')

CREATE TABLE SALARY (EMPLOYEEID INT, SALARY FLOAT)

INSERT INTO SALARY VALUES (1, 10000)
INSERT INTO SALARY VALUES (2, 8000)
INSERT INTO SALARY VALUES (3, 6000)

CREATE TABLE PHONE (EMPLOYEEID INT, PHONENUMBER INT)

INSERT INTO PHONE VALUES (1, 1211123344)
INSERT INTO PHONE VALUES (2, 1111111111)

CREATE TABLE MYPARKING (EMPLOYEEID INT, PARKINGSPOT VARCHAR(20))

INSERT INTO MYPARKING VALUES (1, 'a1')
INSERT INTO MYPARKING VALUES (2, 'a2')

CREATE TABLE MYCUSTOMER (CUSTOMERID INT, CUSTOMERNAME VARCHAR(20))
TRUNCATE TABLE MYCUSTOMER

INSERT INTO MYCUSTOMER VALUES (1, 'Rakesh')
INSERT INTO MYCUSTOMER VALUES (3, 'John')

CREATE TABLE MYORDER (ORDERNUMBER INT, ORDERNAME VARCHAR(20), CUSTOMERID INT)

INSERT INTO MYORDER VALUES (1, 'SOMEORDER1', 1)
INSERT INTO MYORDER VALUES (2, 'SOMEORDER1', 2)
INSERT INTO MYORDER VALUES (3, 'SOMEORDER1', 7)
INSERT INTO MYORDER VALUES (4, 'SOMEORDER1', 8)

--INNER JOIN - Only give rows that are common
SELECT A.FIRSTNAME, A.LASTNAME, B.SALARY
FROM MYEMPLOYEE A INNER JOIN SALARY B ON A.EMPLOYEEID = B.EMPLOYEEID

--LEFT OUTER JOIN - Gives all left rows and only right rows that are common
SELECT A.FIRSTNAME, A.LASTNAME, B.PHONENUMBER FROM MYEMPLOYEE A LEFT JOIN PHONE B
ON A.EMPLOYEEID = B.EMPLOYEEID

--RIGHT OUTER JOIN - Gives all right rows and only left rows that are common
SELECT A.PARKINGSPOT, B.FIRSTNAME, B.LASTNAME FROM MYPARKING A RIGHT JOIN MYEMPLOYEE B
ON A.EMPLOYEEID = B.EMPLOYEEID

--FULL OUTER JOIN - Gives all rows and matches where common
SELECT A.CUSTOMERID, A.CUSTOMERNAME, B.ORDERNUMBER, B.ORDERNAME
FROM MYCUSTOMER A FULL OUTER JOIN MYORDER B
ON A.CUSTOMERID = B.CUSTOMERID

--CROSS JOIN - Joins every row from the 2nd table to each row of the first.
SELECT * FROM MYCUSTOMER CROSS JOIN SALARY


--DATE FUNCTION

SELECT GETDATE()

--DATEPART
SELECT DATEPART(yyyy, GETDATE()) AS YEARNUMBER

--DATEADD
SELECT DATEADD(day, 4, GETDATE())
SELECT DATEADD(day, 4, '11/30/2016')


SELECT TOP 10 * FROM [Production].[WorkOrder]

SELECT workOrderID, ProductID, StartDate, EndDate, DATEDIFF(day, StartDate, EndDate)
FROM [Production].[WorkOrder]


--AGGREGATE FUNCTIONS
SELECT * FROM SALARY

SELECT AVG(SALARY) FROM SALARY
SELECT COUNT(SALARY) FROM SALARY
SELECT SUM(SALARY) FROM SALARY
SELECT MIN(SALARY) FROM SALARY
SELECT MAX(SALARY) FROM SALARY

--STRING FUNCTIONS
SELECT * FROM MYORDER

Print CONCAT('String 1', 'String 2')
SELECT ORDERNUMBER, ORDERNAME, CONCAT(ORDERNAME, ' ', ORDERNAME) AS CONCATENATEDTEXT
FROM MYORDER

SELECT ORDERNUMBER, ORDERNAME, CONCAT(ORDERNAME, ' ', RAND()) AS CONCATENATEDTEXT
FROM MYORDER

SELECT ORDERNUMBER, ORDERNAME, LEFT(ORDERNAME, 5) FROM MYORDER
SELECT ORDERNUMBER, ORDERNAME, RIGHT(ORDERNAME, 5) FROM MYORDER

SELECT ORDERNUMBER, ORDERNAME, SUBSTRING(ORDERNAME, 2, 5) FROM MYORDER

SELECT ORDERNUMBER, ORDERNAME, LOWER(ORDERNAME) FROM MYORDER
SELECT ORDERNUMBER, ORDERNAME, UPPER(ORDERNAME) FROM MYORDER

SELECT ORDERNUMBER, ORDERNAME, LEN(ORDERNAME) FROM MYORDER


--Converting SOMEORDER1 into Someorder1
SELECT ORDERNUMBER, ORDERNAME, CONCAT(UPPER(LEFT(ORDERNAME, 1)), LOWER(SUBSTRING(ORDERNAME, 2, LEN(ORDERNAME)))) FROM MYORDER

--TRIM - Remove space from text
SELECT LTRIM(RTRIM('      myText      '))
